{"version":3,"sources":["../source/RelativeTimeFormat.js"],"names":["version","UNITS","NUMERIC_VALUES","STYLE_VALUES","LOCALE_MATCHER_VALUES","RelativeTimeFormat","preferredVersion","locales","options","numeric","style","indexOf","RangeError","locale","supportedLocalesOf","resolveLocale","value","unit","getRule","replace","Math","abs","rule","valueIndex","type","parts","push","slice","String","length","unitRules","previous","current","next","quantifierRules","quantify","quantifier","other","filter","split","pop","join","addLocale"],"mappings":"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","file":"RelativeTimeFormat.js","sourcesContent":["import {\r\n  getDefaultLocale,\r\n  getLocaleData,\r\n  addLocaleData\r\n} from './LocaleDataStore'\r\n\r\n// The specification is still a draft\r\n// which means that the API can change.\r\n// Use a specific version number so that the\r\n// code doesn't break when the API changes.\r\nlet version = 1\r\n\r\n// Valid time units.\r\nconst UNITS = [\r\n  \"now\",\r\n  \"second\",\r\n  \"minute\",\r\n  \"hour\",\r\n  \"day\",\r\n  \"week\",\r\n  \"month\",\r\n  \"quarter\",\r\n  \"year\"\r\n]\r\n\r\n// Valid values for the `numeric` option.\r\nconst NUMERIC_VALUES = [\r\n  \"auto\",\r\n  \"always\"\r\n]\r\n\r\n// Valid values for the `style` option.\r\nconst STYLE_VALUES = [\r\n  \"long\",\r\n  \"short\",\r\n  \"narrow\",\r\n  // Styles that are valid in Version 1\r\n  // and also used in `JavascriptTimeAgo`.\r\n  \"long_time\",\r\n  \"long_convenient\",\r\n  \"short_time\",\r\n  \"short_convenient\",\r\n  \"tiny\"\r\n]\r\n\r\n// Valid values for the `localeMatcher` option.\r\nconst LOCALE_MATCHER_VALUES = [\r\n  \"lookup\",\r\n  \"best-fit\"\r\n]\r\n\r\n/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */\r\nexport default class RelativeTimeFormat {\r\n  /**\r\n   * Set the specification version (was introduced for backwards compatibility).\r\n   * @param {number} version — Is `1` by default.x\r\n   */\r\n  static useVersion(preferredVersion) {\r\n    version = preferredVersion\r\n  }\r\n\r\n  numeric = \"always\"\r\n  style = \"long\"\r\n\r\n  /**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"best fit\"] - One of: \"lookup\", \"best fit\".\r\n   */\r\n  constructor(locales, options = {}) {\r\n    const { numeric, style } = options\r\n\r\n    // Set `numeric` option.\r\n    if (numeric) {\r\n      if (NUMERIC_VALUES.indexOf(numeric) < 0) {\r\n        throw new RangeError(`Invalid \"numeric\" option: ${numeric}`)\r\n      }\r\n      this.numeric = numeric\r\n    }\r\n\r\n    // Set `style` option.\r\n    if (style) {\r\n      if (STYLE_VALUES.indexOf(style) < 0) {\r\n        throw new RangeError(`Invalid \"style\" option: ${style}`)\r\n      }\r\n      this.style = style\r\n    }\r\n\r\n    // Choose the most appropriate locale.\r\n    // This could implement some kind of a \"best-fit\" algorythm.\r\n    if (locales) {\r\n      this.locale = RelativeTimeFormat.supportedLocalesOf(locales)[0]\r\n    }\r\n    this.locale = this.locale ? resolveLocale(this.locale) : getDefaultLocale()\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */\r\n  format(value, unit) {\r\n    return this.getRule(value, unit).replace('{0}', Math.abs(value))\r\n  }\r\n\r\n  /**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {Object[]} The parts (`{ type, value }`).\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Version 1.\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"day\", value: \"100\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   * //\r\n   * // Version 2.\r\n   * // Returns [\r\n   * //   { type: \"literal\", value: \"in \" },\r\n   * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n   * //   { type: \"literal\", value: \" days\" }\r\n   * // ]\r\n   * rtf.formatToParts(100, \"day\")\r\n   */\r\n  formatToParts(value, unit) {\r\n    const rule = this.getRule(value, unit)\r\n    const valueIndex = rule.indexOf(\"{0}\")\r\n    // \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (valueIndex < 0) {\r\n      return [{\r\n        type: \"literal\",\r\n        value: rule\r\n      }]\r\n    }\r\n    const parts = []\r\n    if (valueIndex > 0) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(0, valueIndex)\r\n      })\r\n    }\r\n    if (version >= 2) {\r\n      parts.push({\r\n        unit,\r\n        type: 'integer',\r\n        value: String(Math.abs(value))\r\n      })\r\n    } else {\r\n      parts.push({\r\n        type: unit,\r\n        value: String(Math.abs(value))\r\n      })\r\n    }\r\n    if (valueIndex + \"{0}\".length < rule.length - 1) {\r\n      parts.push({\r\n        type: \"literal\",\r\n        value: rule.slice(valueIndex + \"{0}\".length)\r\n      })\r\n    }\r\n    return parts\r\n  }\r\n\r\n  /**\r\n   * Returns formatting rule for `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"{0} days ago\"\r\n   * getRule(-2, \"day\")\r\n   */\r\n  getRule(value, unit) {\r\n    // \"now\" is used in `javascript-time-ago`.\r\n    if (UNITS.indexOf(unit) < 0) {\r\n      throw new RangeError(`Unknown time unit: ${unit}.`)\r\n    }\r\n    // Get locale-specific time interval formatting rules\r\n    // of a given `style` for the given value of measurement `unit`.\r\n    //\r\n    // E.g.:\r\n    //\r\n    // ```json\r\n    // {\r\n    //  \"past\": {\r\n    //    \"one\": \"a second ago\",\r\n    //    \"other\": \"{0} seconds ago\"\r\n    //  },\r\n    //  \"future\": {\r\n    //    \"one\": \"in a second\",\r\n    //    \"other\": \"in {0} seconds\"\r\n    //  }\r\n    // }\r\n    // ```\r\n    //\r\n    const unitRules = getLocaleData(this.locale)[this.style][unit]\r\n    if (typeof unitRules === \"string\") {\r\n      return unitRules\r\n    }\r\n    // Special case for \"yesterday\"/\"today\"/\"tomorrow\".\r\n    if (version >= 2 && this.numeric === \"auto\" && unit === \"day\") {\r\n      switch (value) {\r\n        // \"yesterday\"\r\n        case -1:\r\n          if (unitRules.previous) {\r\n            return unitRules.previous\r\n          }\r\n          break\r\n        // \"today\"\r\n        case 0:\r\n          if (unitRules.current) {\r\n            return unitRules.current\r\n          }\r\n          break\r\n        // \"tomorrow\"\r\n        case 1:\r\n          if (unitRules.next) {\r\n            return unitRules.next\r\n          }\r\n          break\r\n      }\r\n    }\r\n    // Choose either \"past\" or \"future\" based on time `value` sign.\r\n    // If \"past\" is same as \"future\" then they're stored as \"other\".\r\n    // If there's only \"other\" then it's being collapsed.\r\n    const quantifierRules = unitRules[value <= 0 ? \"past\" : \"future\"] || unitRules\r\n    if (typeof quantifierRules === \"string\") {\r\n      return quantifierRules\r\n    }\r\n    // Quantify `value`.\r\n    const quantify = getLocaleData(this.locale).quantify\r\n    let quantifier = quantify && quantify(Math.abs(value))\r\n    // There seems to be no such locale in CLDR\r\n    // for which `quantify` is missing\r\n    // and still `past` and `future` messages\r\n    // contain something other than \"other\".\r\n    /* istanbul ignore next */\r\n    quantifier = quantifier || 'other'\r\n    // \"other\" rule is supposed to always be present.\r\n    // If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n    return quantifierRules[quantifier] || quantifierRules.other\r\n  }\r\n\r\n  /**\r\n   * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n   * @return {Object}\r\n   */\r\n  resolvedOptions() {\r\n    return {\r\n      locale: this.locale\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {Function} [options.localeMatcher] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\"; the default is \"best fit\". For information about this option, see the Intl page.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'de-ID'];\r\n * var options = { localeMatcher: 'lookup' };\r\n * console.log(Intl.RelativeTimeFormat.supportedLocalesOf(locales, options).join(', '));\r\n * // → \"id-u-co-pinyin, de-ID\"\r\n */\r\nRelativeTimeFormat.supportedLocalesOf = function(locales, options) {\r\n  // Convert `locales` to an array.\r\n  if (typeof locales === 'string') {\r\n    locales = [locales]\r\n  }\r\n  // This is not an intelligent algorythm,\r\n  // but it will do for the polyfill purposes.\r\n  // This could implement some kind of a \"best-fit\" algorythm.\r\n  return locales.filter(resolveLocale)\r\n}\r\n\r\n/**\r\n * Resolves a locale to a supported one.\r\n * @param  {string} locale\r\n * @return {string}\r\n */\r\nfunction resolveLocale(locale) {\r\n  if (getLocaleData(locale)) {\r\n    return locale\r\n  }\r\n  // `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\r\n  const parts = locale.split('-')\r\n  while (locale.length > 1) {\r\n    parts.pop()\r\n    locale = parts.join('-')\r\n    if (getLocaleData(locale)) {\r\n      return locale\r\n    }\r\n  }\r\n}\r\n\r\nRelativeTimeFormat.addLocale = addLocaleData\r\n\r\n/**\r\n * Extracts language from an IETF BCP 47 language tag.\r\n * @param {string} languageTag - IETF BCP 47 language tag.\r\n * @return {string}\r\n * @example\r\n * // Returns \"he\"\r\n * getLanguageFromLanguageTag(\"he-IL-u-ca-hebrew-tz-jeruslm\")\r\n * // Returns \"ar\"\r\n * getLanguageFromLanguageTag(\"ar-u-nu-latn\")\r\n */\r\n// export function getLanguageFromLanguageTag(languageTag) {\r\n//   const hyphenIndex = languageTag.indexOf('-')\r\n//   if (hyphenIndex > 0) {\r\n//     return languageTag.slice(0, hyphenIndex)\r\n//   }\r\n//   return languageTag\r\n// }"]}